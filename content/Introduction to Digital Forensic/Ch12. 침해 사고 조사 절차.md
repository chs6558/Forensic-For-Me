---
title: "11장 리눅스 시스템 조사"
metaTitle: ""
metaDescription: ""
---

리눅스 시스템은 유닉스를 기반으로 개발된 운영체제이다. '리눅스'라는 용어 자체는 실제로 커널만을 의미하지만 오늘날에는 리눅스 커널을 포함, GNU 프로젝트의 라이브러리와 도구를 포함하여 '리눅스'라고 한다. 리눅스 시스템은 대표적인 오픈 소스 소프트웨어로써 다중 사용자를 지원하며 멀티 테스킹 기능을 제공한다. 

## 리눅스 시스템의 특징

**가. 명령어 기반**

리눅스는  명령어 기반 시스템이다. GUI 방식보다, 문자를 기반으로한 입,출력을 수행한다. 이는 커널이 명령어 기반의 입/출력을 하도록 작성되어 있기 때문이다. 

**나. 디렉토리와 파일**

​	**1) 디렉토리 구조**

리눅스에는 윈도우와 달리 드라이브 문자( C:Drive) 와 같은 문자가 존재하지 않으며 필요한 파일 시스템을 마운트 하여 사용한다. 디렉토리 구분자로는 '/'를 사용하며, 디렉토리의 이름은 대/소문자를 구분한다. 최대 255글자까지 가능하며 root directory는 /로 표시한다.

/ : 최상위 디렉토리
/bin : ls, cp와 같은 기본 명령어 저장
/boot : 시스템이 부팅하기 위해 필요한 파일이 저장
/dev : 각 장치를 의미하는 파일이 저장
/etc : 시스템 설정에 대한 파일 저장
/home : 홈 디렉토리는 각 사용자에게 할당된 기본 디렉토리를 저장
/lib : 시스템의 공유 라이브러리 저장
/lost+found : 파일 시스템 이상 여부를 진단하고 복구하는 fsck 명령어가 사용하는 Directory. 특정 파일의 위치를 결정할 수 없는 경우 여기 보관
/mnt : 마운트를 위한 Directory
/proc : 가상 파일 시스템으로 실제 디스크에 저장 x, 시스템에서 실행되는 프로세스 정보 저장
/usr : 사용자가 설치한 응용 프로그램, 소스코드 등이 저장
/root : super user인 root의 홈 Directory
/sbin : 슈퍼 유저가 사용하는 명령어 저장
/var : 로그 파일 이나 printer spool file 등 시스템의 동작중에 변화하는 파일이 저장

​	**2) 파일 특성**

윈도우 실행파일은 'exe', '.com' 과 같은 확장자를 가져야 하지만 리눅스는 그러한 제약이 없다. 파일의 권한을 통해 실행 여부를 결정한다. 

​		**(1) Symbolic Link**

심볼릭 링크 파일은 윈도우의 바로가기와 유사하다. 

​		**(2) Hard Link**

하드 링크는 원본을 복사하여 사본을 생성한다. 하드링크 파일에 대한 작업을 수행하는 경우 원본에도 동일한 영향이 미치는점은 심볼릭 링크와 동일하다. 심볼릭 링크는 원본 파일이 제거되면 사라지지만, 하드 링크는 제거되지 않고 원본의 내용을 그대로 가진다. 주로 파일을 공유하면서 안전하게 보관할 때 사용한다. 

​		**(3) D&F의 소유 및 접근 제어**

리눅스에는 접근 권한이 3가지가 있다.

1. Read
2. Write
3. Execute

이는 그룹 또는 사용자에게 부여할 수 있다. 

​		**(4) SUID, SGID**

SUID 와 SGID는 특정 실행 파일을 사용할 때 해당 파일의 소유자 또는 그룹의 권한으로 실행할 수 있도록 한다. 

**다. Daemon**

리눅스 시스템에서 백그라운드로 동작하는 서버 프로그램을 의미. 윈도우의 서비스와 유사하다. 일반적으로 시스템이 시작할 때 동작하기 시작하며, httpd 와 같이 제공하는 서버의 이름에 d를 붙여 표시하는 경우가 많으며 동작 과정을 로그 파일에 남긴다. 



## 리눅스 환경 설정 파일

**가. 사용자 및 그룹 설정**

사용자 및 그룹 파일은 시스템에서 가장 중요한 정보로, 공겨가작 시스템에 접속할 수 있는 시발점으로 사용할 수 있다. 따라서 **침해사고를 조사할 때에는 불필요한 계정의 유무, 잘못된 그룹, 빈 패스워드 설정 계정 등이 있는지 확인해야 한다.**

​	**1) /etc/passwd**

시스템의 모든 계정은 /etc/passwd에 저장된다. 

username:password:uid:gid:gecos:homedir:program

username : 계정명
password : 패스워드가 암호화 되어 저장된다
uid : 사용자 ID, username과 1대1 대응
gid : 사용자가 속해있는 그룹의 ID
gecos : 사용자의 부가정보를 저장
homedir : 각 사용자의 홈 디렉토리
program : 사용자가 로그인한 후에 실행되는 프로그램

​	**2) /etc/shadow**

/etc/passwd 파일은 모든 사용자가 read가능하기 때문에 암호화된 패스워드가 노출된다. 이를 방지하기 위해 암호화된 패스워드를 별도로 보관하고 super user만 읽을 수 있도록 한 파일을 shadow 파일이라 한다. 

​	**3) /etc/group**

그룹과 그룹에 속해있는 사용자에 대해 저장하고 있다. 모든 사용자는 반드시 하나의 그룹에 속해야 한다. 

groupname:password :memeber1:member2...

password : 그룹에 지정된 패스워드이다. 그룹의 멤버가 아니여도 패스워드를 알고 있는 사용자는 그룹의 권한을 얻을 수 있다. 

**나) 파일 시스템 설정 **

파일 시스템과 관련된 설정은

/etc/fstab 	/etc/mtab

에 저장되어 있다. 파일 시스템에 대한 정의는 로컬 시스템에 한정되지 않고, NFS(Network File System)과 같이 원격지 시스템에 대한 마운트 정보 역시 파일 시스템 설정에 기록될 수 있다. **로컬 파일 시스템에 대한 분석을 수행하기 전에 분석 대상 시스템에 설정되어 있는 파일 시스템 설정을 확인해야 한다. **

​	**1) /etc/fstab**

시스템을 부팅하면서 각 장치를 자동으로 마운트할 때 사용하거나 mount -a 명령어 사용시 사용된다. 마운트 하기위한 정보를 저장한다. 

​	**2) /etc/mtab**

현재 마운트가 되어있는 정보를 저장한다. mount 명령어에 parameter를 주지 않으면 /etc/mtab의 내용이 출력된다. 주로 mount, unmount 명령에 의해 기록 및 삭제되지만, mount -n 옵션을 사용하면 /etc/mtab에 내용을 기록하지 않으므로 현재 시스템 마운트 상황과 완전히 일치하는 것은 아니다. 

**다. 네트워크 설정 파일**

​	**1) 네임 서버 설정**

네임 서버는 일반적으로 사용하는 도메인 주소 또는 Webserver와 같이 특정 이름을 사용하는 경우 이를 IP 주소로 바꾸어주는 역할을 한다. 이렇게 주소를 바꾸어 주는 서비스는 로컬의 네임 서비스 정보를 이용하는 호스트 설정과 원격의 DNS 서버를 통해 IP 주소를 알아내는 DNS 서비스가 있다. 

​		**가) 호스트 설정**

호스트 설정 파일은 로컬에서 운용되는 네임 서비스라 할 수 있다. 호스트 설정은 DNS 서버를 거치지 않고 지정된 IP 주소를 사용하게 할 수 있으며, IP spoofing 방지, 특정 호스트에 대한 접근 제어 등을 수행할 수 있다. 잘못된 호스트 파일의 설정은 시스템 사용자가 인식하지 못하는 상태에서 공격자의 사이트로 유도될 수 있다. 

​			**(1) /etc/hosts.conf**

네임 서비스를 어떻게 동작시킬 것인지를 결정한다. 옵션은 아래와 같다.

order : 네임 서비스가 동작하는 순서를 결정한다.
alert : on/off 로 설정가능하고, IP 스푸핑이 발생하면 syslog에 기록한다.
multi : on/off로 설정할 수 있다. 동일한 호스트에 여러 IP 주소를 부여할 수 있도록 한다.
nospoof : on/off로 설정할 수 있다. 주소를 이용하여 IP를 얻어내는 것과 IP를 통해 주소를 얻는 두가지 방법을 모두 수행하여 두 개가 일치할 경우에만 IP 주소를 전달한다.
trim : 도메인 주소를 파라미터로 설정한다. hosts 파일을 참조할 떄 도메인을 입력하지 않아도 자동으로 찾을 수 있게 한다. 

​		**(2) /etc/hosts**

호스트의 이름과 IP 주소의 쌍으로 구성되어 있다. 

​		**(3) /etc/hosts.allow, /etc/hosts.deny**

외부의 접근을 허용 또는 차단하기 위해 사용한다. 다음과 같은 방식으로 설정한다.

ALL : 192.168.0.
ALL : 192.168.1. EXCEPT 192.168.1.100
ALL : .korea.ac.kr EXCEPT malware.korea.a.c.kr

​	**나) DNS 설정**

간단하게 설정되어 있다. 

nameserver 192.168.80.2
nameserver 192.168.80.3

​	**2) 네트워크 인터페이스 카드 (NIC) 설정**

NIC의 정보는 /etc/network/interfaces에 저장되어 있다. 



## 자동 실행 프로그램

실행 순서는 일반적으로 스크립트에 의존하며 용도와 스크립트의 위치도 다르다. 용도에 따라 시스템이 부팅하거나 종료할 때의 자동 실행, 로그인 등으로 인해 쉘이 시작할 때의 자동 실행, 데몬에 의해 주기적인 자동 실행 등의 방법이 있다. 

**가. 시스템의 시작/종료시의 자동 실행 파일**

시스템이 시작/종료할 때, 자동으로 실행되는 파일은 RunLevel에 의존한다. 실행레벨은 0~6까지 있으며, 리눅스 배포판에 따라 실행레벨의 정의는 달라질 수 있다. 

**나. 사용자 동작에 따른 자동 실행 파일**

사용자가 로그인하여 쉘을 실행시키거나 새로운 쉘로 진입하는 경우, 특정 프로그램을 이용하는 경우에 자동으로 실행되는 쉘 스크립트가 있다. 이러한 자동 스크립트 파일은 일반적으로 사용자의 /home 에 있다. 

​	**1) .bashrc, .bash_profile, .bash_logout**

bash 쉘이 동작할 때 마다 자동으로 실행되는 스크립트이다. ".bashrc"는 bash 쉘이 실행할 때 마다 실행되고, ".bash_profile"은 bash 쉘이 로그인 쉘로 이용되었을 때만 동작한다. ".bash_logout"는 bash 로그인 쉘이 종료되었을 경우에 실행된다. 이 외에도 bash 쉘에 관련되 자동 실행 스크립트는 /etc/profile, /etc/bashrc도 있다. /etc directory의 파일은 사용자의 홈 디렉토리에 있는 스크립트가 동작할 때 해당 파일의 유무를 검사하여 있으면 실행시킨다. 

​	**2) ".cshrc", ".login"**

c 쉘이나 tcsh가 실행할 때 자동으로 실행되는 스크립트 파일이다. "./login" 은 bash 쉘의 "./bash_profile"과 같이 로그인할 때만 작동한다. 

​	**3) ".kshrc"**

Korn 쉘이 실행할 때 자동으로 실행되는 스크립트 파일이다.

​	**4) .vimrc**

텍스트 편집기인 vi, vim 에디터를 이용할 경우에 자동으로 실행된다. 

​	**5) .xinitrc**

X 윈도우가 구동될 때 자동으로 실행된다. 

**다. crontab ( 작업 스케줄링 ) **

crontab은 리눅스 시스템에서 사용하는 작업 스케줄링 데몬이다. 작업 스케줄링 정보는 /etc/crontab 파일 내에 저장되어 있다. 

Min Hour Day Month DayOfWeek Command 



## 시스템 로그 파일

리눅스는 시스템의 로그를 기록하기 위핵 기본적으로 syslog 데몬을 이용한다. syslog 데몬은 운영체제의 동작과정에서 발생하는 로그를 기록하며, 다른 데몬 프로그램이 발생시키는 로그 역시 기록하는 역할을 수행한다. 일반적으로 시스템에 의해 발생된 로그는 /var/log 디렉토리에 기록된다. syslog 외에도 bash 쉘에 의해 기록되는 명령어 히스토리가 존재하며 사용자 접속 기록은 utmp 파일과 wtmp 파일에 기록한다. 

시스템 로그는 윈도우 시스템의 이벤트 로그와 유사하게 시스템에서 발생한 일에 대해 자세히 기록하므로 리눅스 시스템에서 발생된 사건에 대해 많은 정보를 제공한다. 

**가. 명령어 히스토리**

사용자가 입력한 명령어의 히스토리는 각 사용자의 홈 디렉토리에 저장된다. bash 쉘은 ".bash_history" 파일에 입력한 명령어를 기록한다. 명령어 히스토리 파일에 기록되는 명령어의 수는 $HISTSIZE 환경 변수에 기록되어 있으며 기록되는 값을 보기 위해서는 다음과 같은 명령어를 입력하면 된다. 

**나. /var/log/wtmp 	/var/run/utmp	 /var/log/lastlog**

/var/log/wtmp : 로그인 시간과 사용자가 시스템에 연결한 기간과 재부팅할 때의 부팅기록을 바이너리 파일로 기록한다. 
사용자의 로그인 목록을 생성하는 last 명령이 /var/log/wtmp 파일을 사용한다.

/var/run/utmp : 시스템에 현재 로그인 되어 있는 사용자의 정보를 저장하고 있는 바이너리 파일이다. who, w, finger 등을 통해 내용을 볼 수 있다. 

/var/log/lastlog : 각 계정이 마지막으로 로그인한 시간을 저장하고 있는 바이너리 파일이다. lastlog 명령어를 이용하여 파일의 내용을 볼 수 있다. 

**다. /var/log/dmesg**

시스템이 부팅할 때 출력하는 메시지를 기록하는 로그 파일이다. 시스템의 하드웨어 설정 및 로드된 디바이스 드라이버 등을 확인할 수 있다. 

**라. /var/log/messages**

시스템에서 발생하는 각종 로그를 기록한 파일이다. 운영체제가 동자갛며 발생하는 하드웨어 및 소프트웨어의 이벤트와 에러를 기록한다. 

**마. /var/log/auth.log**

관리자 권한으로 실행된 명령에 대해 시간, 계정명, 시도한 작업, 실패 여부 등을 저장한다. 



## /proc 파일 시스템

리눅스 시스템이 동작하기 위한 커널 정보를 메모리 계층 구조로 구현한 것이다. 따라서 메모리에만 존재하며 일반 사용자 및 관리자가 커널의 데이터를 쉽게 접근할 수 있도록 한다. /proc 파일 시스템에는 현재 동작중인 프로세스 정보 외에도 CPU 사용, 인터럽트, I/O 포트 정보, 장치정보등을 쉽게 가져올 수 있어 시스템의 현재 상태를 알아내는데 매우 중요하다. 

/proc 파일 시스템의 내용은 **시스템 정보**와 **프로세스 정보**로 구분할 수 있다. 

**가. 시스템 정보** 

​	**1) cmdline**

부팅할 때 사용했던 커널 파라메터를 출력한다. 

​	**2) cpuinfo**

시스템에 정착되어 있는 모든 프로세서에 대한 정보를 보관한다. 멀티 프로세서 환경에서 동작하는 도구를 사용하거나 엔디안 문제가 발생할 가능성이 있는 경우 프로세서의 내용을 확인해야 한다. 

​	**3) diskstats**

디스크 I/O에 대한 통계를 나타낸다. 굵게 표시한 부분에서 앞부분은 읽은 섹터의 개수, 뒷부분은 쓰여진 섹터의 개수이다. 

​	**4) driver/rtc**

하드웨어적인 시스템 쿨럭인 RTC(Real Time Clock)을 가진다. 

​	**5) filesystem**

커널에서 지원하는 파일 시스템을 보여준다. NODEV로 나타나는 부분은 별도의 물리적인 장치가 필요없음을 의미한다. 

​	**6) /kallsyms, ksyms**

커널에서 사용되는 전역 변수, 함수 등의 심볼을 보관한다. 

​	**7) kcore**

프로그램에서 크래쉬가 발생했을 때 생성되는 "core" 파일과 동일한 형식의 파일이다. 커널의 물리적 메모리를 나타내며 GNU Debugger를 통해 디버깅 할 수 있는 형태로 제공된다. 

​	**8) modules**

커널에 로드된 모든 모듈의 이름과 커널 주소를 가지고 있다. 

​	**9) mounts**

NFS를 포함하여 현재 마운트 되어 있는 모든 장치를 가지고 있다. 

​	**10) partitions**

시스템의 각 파티션에 대한 정보를 제공한다. 

​	**11) sys directory**

커널 내부에서 사용하는 변수에 대한 정보를 파일로 보관하고 있다. 각 장치와 파일 시스템, 모듈 등에서 사용되는 내부 값을 열람 또는 수정할 수 있다. 

​	**12) uptime**

시스템이 동작한 시간을 나타내는 값과 그 중 Idle 시간이 얼마나 되는지에 대한 두개의 시간 값을 가지고 있다. 각 시간은 초단위로 기록된다. 

​	**13) version**

gcc 버전과 리눅스 커널의 버전을 가지고 있다. 

​	**14) meminfo**

메모리의 사용량 및 상태에 대한 통계 값을 가지고 있다. 

**나. 프로세스 정보**

각 프로세스 ID의 디렉토리는 하나의 프로세스가 동작하기 위해 필요한 실행 파일, 연결된 파일, 네트워크 등의 정보를 저장하고 있다. 게다가 **각 프로세스 ID 디렉토리는 현재 동작하고 있는 프로세스 뿐만 아니라 기존에 실행되었던 프로세스도 남아 있는 경우가 있어 침해사고 분석에 유용하다.** 

​	**1) exe**

실제 실행 파일의 이미지에 대한 심볼릭 링크이다. 

​	**2) cmdline**

프로세스가 시작할 때, 입력한 실행 파일명과 파라메터를 포함하는 명령어 구문을 의미한다. 

​	**3) cwd** 

프로세스의 작업 디렉토리의 심볼릭 링크이다. 

​	**4) environ**

프로세스를 위한 환경 변수를 보관하고 있다. 

​	**5) fd 디렉토리**

프로세스와 관련된 모든 파일의 디스크립터에 대한 정보를 저장하고 있다. 

​	**6) loginuid**

시스템에 접속한 UID를 나타낸다. 만약 공격자가 일반 사용자 계정으로 로그인 후 , su sudo 등의 명령어를 이용하여 root 권한으로 프로그램을 실행시켜도 loginuid에는 최초 접속했던 계정의 UID가 기록된다. 



## 활성 시스템 조사.

리눅스 버전, 계열에 따라 비휘발성 데이터가 저장되는 위치와 형태가 모두 다를 수 있기 때문에 shell script를 제작하는 방법을 권장한다. 